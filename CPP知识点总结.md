# CPP知识点总结

## 1. struct和class

struct:一般表示为一个数据结构的实现体

class:通常看成是一个对象的实现体

区别：(1)默认访问控制：struct是public，class是private的访问控制权限

​			(2)默认继承权限：struct是public，class是private.

## 2. 面向对象

面向对象程序设计(Object-oriented programming, OOP)

三大特性：封装、继承、多态

![image-20210822151852792](https://raw.githubusercontent.com/xjs-xrhm/Images/main/202108221518973.png)

### 1.封装

将成员变量和函数集合在一起

关键字：public、protected、private；默认为private

public成员：可以被任意实体访问

protected成员：只允许被子类和本类的成员函数访问

private成员：只允许被本类的成员函数、友元函数访问

### 2.继承

基类(父类)--->派生类(子类)

### 3.多态

即多种状态，多态是以封装和继承为基础的

C++多分类及实现：

1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 
2. 子类型多态（Subtype Polymorphism，运行期）：虚函数 
3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 
4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

## 3.内存分配和管理

### malloc和free

malloc:申请指定字节数的内存，申请到的内存中的初始值不确定

free释放内存，之后需要指针置空

### new和delete

new:先底层调用malloc分配内存，然后调用构造函数(创建对象)

delete:先调用析构函数(清理资源)，然后底层调用free释放空间

## 4.智能指针

头文件：

```c++
#include<memory>
```

C++11:

1.shared_ptr

2.unique_ptr

3.weak_ptr

4.auto_ptr(被C++11弃用)

share_ptr：多个智能指针可以共享同一个对象，最后一个指针被销毁时，被释放

weak_ptr:允许你共享但不拥有某对象，一旦最后一个拥有该对象的智能指针失去了拥有权，任何wak_ptr都会自动变成空(empty)

unique_ptr:采用独占式拥有，可以确保一个对象和其相应的资源在同一时间只被一个指针拥有。

## 5. C++程序的编译过程

编译过程分为四步：编译预处理、编译、汇编、链接

- 编译预处理：处理以#开头的指令
- 编译：将源码 .cpp文件翻译成 .s汇编文件
- 汇编：将汇编代码 .s翻译成机器指令 .o文件
- 链接：链接需要的目标文件形成一个整体，从而生成可执行文件 .exe文件

## 6. 链接过程

链接分为两种：

- 静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中
- 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

二者的优缺点：

- 静态链接 浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容
- 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。

## 7. 指针和引用的区别

- 指针所指向的内存空间在程序运行的过程中可以改变，而引用所绑定的对象一旦绑定就不能改变
- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间
- 指针可以为空，但引用必须绑定对象
- 指针可以有多级，但引用只能一级

## 8. 栈和堆的区别

- 申请方式：栈由系统自动分配，堆是程序员主动申请
- 申请后系统响应：如果剩余空间大于申请空间则分配成功，否则分配失败，栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上
- 栈在内存中是连续的一块空间(向低地址扩展)最大容量是系统预定好的；堆在内存中的空间(向高地址扩展)是不连续的
- 申请效率：栈是由系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片
- 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制

## 9. new和delete是如何实现的，new和malloc的异同处

在使用的时候new,delete搭配使用，malloc和free搭配使用

- 属性：malloc/free是库函数，需要头文件的支持；new/delete是关键字，需要编译器的支持
- 参数：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请空间的大小
- 返回值：new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针

- 分配失败：new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回空指针
- 重载：new/delete 支持重载，malloc/free 不能进行重载
- 自定义类型实现：new 首先调用 operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。malloc/free 无法进行自定义类型的对象的构造和析构
- 内存区域：new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

## 10. C 和 C++ 的区别

- C 是面向过程的编程，特点是函数；C++ 是面向对象的编程，特点是类。（特性）
- C 主要用在嵌入式开发、驱动开发和硬件直接打交道的领域；C++ 可以用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。（应用领域）
- C++ 继承了C的底层操作特性，增加了面向对象的机制，增加了泛型编程、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。（相较于 C 的升级）

## 11. C++、Java的联系与区别，包括语言特性、垃圾回收等

二者在语言特性上有很大的区别：

- 指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；JAVA 并不是没有指针，虚拟机(JVM)内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 JAVA 增加了内存管理机制
- 多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；JAVA 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便
- 数据类型和类：C++ 可以将变量或函数定义成全局，但是JAVA是完全面向对象的语言，除了基本的数据类型之外，其他的都作为类的对象，包括数组。

垃圾回收：

- JAVA 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存
- JAVA 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，JAVA 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 JAVA 中的内存回收是以线程的方式在后台运行的，利用空闲时间。

应用场景：

- java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持，
- C++ 可以直接编译成可执行文件，运行效率比 JAVA 高
- JAVA 主要用来开发 web 应用
- C++ 主要用在嵌入式开发、网络、并发编程的方面

## 12. define和const的区别

- 编译阶段：define 是在编译预处理阶段起作用，const 是在编译阶段和程序运行阶段起作用
- 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的只读变量是有类型的，是要进行判断的，可以避免一些低级的错误
- 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const 定义的只读变量在程序运行过程中只有一份
- 调试：define 定义的不能调试，因为在预编译阶段就已经进行替换了；const 定义的可以进行调试

const 的优点：

- 有数据类型，在定义式可进行安全性检查
- 可调式
- 占用较少的空间

## 13. 在C++中const和static的用法

const：

- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率
- const 修饰函数参数，使得传递过来的函数参数的值不能改变
- const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外，函数参数也除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量

static定义静态变量，静态函数

- static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间
- static 作用于全局变量和函数，改变了全局变量的作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性
- static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数

## 14. 类的大小

类本身没有大小，其大小是指类对象所占的大小

- 类的大小遵循结构体对齐原则
- 类的大小与普通成员函数和静态成员无关(包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员)，与普通数据成员有关
- 虚函数对类的大小有影响，是因为虚函数指针的影响
- 虚继承对类的大小由影响，是因为虚基表指针带来的影响
- 空类的大小是1

## 15. C++中重载和重写的区别

- 对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间，子类和父类之间
- 重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰
- virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有

## 16. C++内存管理

C++内存分区：栈、堆、自由存储区、全局/静态存储区、常量区

- 栈：存放函数的局部变量，由编译器自动分配和释放
- 堆：动态申请的内存空间，就是由malloc分配的内存块，由程序员控制它的分配和释放；如果程序执行结束还没有释放，操作系统会自动回收
- 自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存
- 全局/静态区：存放全局变量和静态变量
- 常量区：存放的是常量，不允许修改

堆和自由存储区的区别：

- 自由存储是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存
- new 所申请的内存区域在 C++ 中成为自由存储区。藉由堆实现的自由存储，可以说 new 所申请的内存区域在堆上
- 堆和自由存储区有区别，并非等价。使用 new 来分配内存，程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

## 17. 在一个函数中如何返回一个变量指针？

对于普通变量而言，是存储在栈内存中，当函数调用完毕后，栈内存的空间会被释放，如果返回局部变量的指针，回到主调函数后，该指针是悬挂指针指向垃圾内存，如何来处理这种情况呢？

可以返回存储在堆内存或者全局区的变量的指针：

- 返回静态类型对象的指针，会导致占用大量的内存空间
- 返回存放在堆上的对象的指针，该对象所在的内存空间由用户控制什么时候释放，那如何知道什么时候释放合适呢？可以用只智能指针来处理，智能指针内部有计数器，当计数器为 0 时，会自动释放该内存。

## 18. 出现野指针的情形

- 指针定义的时候未初始化
- 指针指向动态分配的内存空间在释放（delete 或 free）后，未置为 NULL，让人误以为是合法指针
- 指针操作超过了变量的作用范围。例如：在函数中将一个局部变量的地址作为函数的返回值，这里编译器会给出警告，因为离开该函数后，局部变量的空间就会释放掉，返回的地址（指针）相当于是野指针。

## 19. C++虚函数相关(虚函数表，虚函数指针)，虚函数的实现原理

虚函数是通过虚函数表来实现的，虚函数表里面保存了虚函数的地址，这张表保存在含有虚函数的类的实例对象的内存空间中，虚函数表的指针存放在对象实例的最前面的位置.

虚函数表是在编译阶段建立的，也就是说在程序的编译过程中会将虚函数的地址放在虚函数表中。

## 20. 编译器处理虚函数表

- 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。
- 如果派生类没有重新定义基类的虚函数A，则派生类的虚函数表中保存的是基类的虚函数A的地址，也就是说基类和派生类的虚函数A的地址是一样的
- 如果派生类重写了基类的某个虚函数B，则派生的虚函数表中保存的是重写后的虚函数B的地址，也就是说虚函数B有两个版本，分别存放在基类和派生类的虚函数表中
- 如果派生类重新定义了新的虚函数C，派生类的虚函数表保存新的虚函数C的地址

## 21. 析构函数一般写成虚函数的原因

析构函数定义成虚函数是为了防止内存泄漏，因为当父类的指针或者引用指向或绑定到子类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

## 22. 构造函数为什么一般不定义为虚函数

- 从存储空间的角度考虑，构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。
- 从使用的角度来看，虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的
- 从实现上来看，虚函数表是在创建对象之后才有的，因此不能定义成虚函数
- 从类型上来看，在创建对象时需要明确其类型

## 23. 构造函数或者析构函数中调用虚函数会怎么样

**程序可以正常运行**

- 但是无法达到虚函数调用的效果，当用基类的指针指向派生类的对象时，在调用基类的构造函数时，若出现虚函数的调用，程序的本意是调用派生类中的虚函数，但是当虚函数出现在构造函数或者析构函数中时，调用的是其所在类（基类）的虚函数。派生类对象构造期间进入基类的构造函数时，对象的类型变成了基类类型，而不是派生类类型。同样进入基类析构函数时，对象也是基类类型。

## 24. 静态绑定和动态绑定

**静态类型和动态类型：**

- 静态类型：变量在声明时的类型，是在编译期确定的。静态类型不能更改
- 动态类型：目前所指对象的类型，是在运行期确定的。动态类型可以更改

**静态绑定和动态绑定：**

- 静态绑定是指程序在编译的过程中确定对象的类型（静态类型）
- 动态绑定是指程序在运行期间确定对象的类型（动态类型）

**静态绑定和动态绑定的区别：**

- 发生的时期不同：如上
- 对象的静态类型不能更改，动态类型可以更改
- 要想实现多态，必须进行动态绑定
- 在继承体系中，只有虚函数是动态绑定，其他都是静态绑定

## 25. 编译时多态和运行时多态

- 编译时多态：在程序编译过程中出现， 发生在模板和函数重载中（泛型编程）
- 运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数

**编译时多态和运行时多态的区别：**

- 编译时多态发生在程序编译过程中，运用泛型编程来实现，在编译时完成，提升程序的运行效率，但是对于无法实现模板的分离编译对于大程序编译时十分耗时
- 编译时多态无法处理异质对象的集合（异质对象是通过异质类定义的，异质类是指存储类型不一致的数据对象）
- 运行时多态体现了面向对象的特征，但是虚函数会占用一定的存储空间
- 运行时多态发生在程序的运行过程中，编译器无法进行优化处理

**引申出：显示接口和隐式接口**

- 显示接口：能够明确来源的接口，例如在运行时多态中，能够明确的知道所调用的函数是来源于哪个类
- 隐式接口：无法确定来源的接口，例如对于函数重载和模板，不知道是调用哪个实现

## 26. 深拷贝和浅拷贝的区别

如果一个类拥有资源，该类的对象发生了复制，如果资源发生了重新分配，就是深拷贝，否则就是浅拷贝

- 深拷贝：该对象和原对象占用不同的存储空间，即拷贝位于stack域（栈）中的内容，又拷贝类中位于heap域（堆）中的内容
- 浅拷贝：该对象和原对象占用同一块内存区域，仅拷贝类中位于stack域（栈）中的内容

当类的成员变量中有指针时，使用深拷贝安全，如果两个对象指向同一块内存空间，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

## 27. 介绍C++所有构造函数

构造函数的作用：当创建对象时，系统分配了内存空间后，会自动调用相应的构造函数

- 默认构造函数：没有参数，如果创建了一个类，没有定义任何构造函数，系统会自动生成默认的构造函数
- 一般构造函数：带有参数，一个类可以有若干个一般构造函数，前提是参数的数量或者类型不同（C++重载函数原理）
- 拷贝构造函数：参数为该类的常量引用对象，如果类中没有定义拷贝构造函数，系统会默认生成一个默认的拷贝构造函数，默认生成的拷贝构造函数都是浅拷贝的
- 赋值构造函数：区别于以上构造函数，以上构造函数都没有函数的返回类型，这里虽然称为“赋值构造函数”，其实是“重载了赋值运算符的函数”，该函数的返回类型是该类的引用类型，参数是该类的常量引用对象。

## 28. 拷贝构造函数(复制)和赋值构造函数(赋值)的区别

- 二者的参数类型都是该类的常量引用对象，但是，拷贝构造函数没有返回类型，赋值构造函数的返回类型是该类的引用类型
- 在实现过程中，调用拷贝构造函数是在创建一个新的对象时，所以在函数内直接申请空间(heap)然后给相应的成员变量赋值即可；调用赋值构造函数时，源对象和目标对象都已声明，所以在函数内需要将目标对象的内存空间（heap）释放掉，重新申请空间，再进行拷贝操作
- 二者的使用场景不同，拷贝构造函数的使用场景见如下三种情况

## 29. 内存泄漏的定义，如何检测与避免？

**内存泄漏：**由于疏忽或错误导致程序未能释放掉不再使用的内存，并不是说这块内存在物理上消失，而是说失去了对这块内存的控制，因而造成了内存的浪费

**检测内存泄漏的方法：**

- 使用工具软件BoundChecker
- 运行DEBUG版程序，运用以下技术：CRT(C Run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号，综合分析内存泄漏的原因

**解决内存泄漏的方法：智能指针**

## 30. weak_ptr如何解决shared_ptr的循环引用问题？

循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏

- weak_ptr对被shared_ptr管理的对象存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为shared_ptr
- -weak_ptr用来打断shared_ptr所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr引用计数无法抵达0，内存被泄露； 能令环中的指针之一为弱指针可以避免该情况
- weak_ptr用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用weak_ptr跟踪该对象；需要获得所有权时将其转化为shared_ptr，此时如果原来的shared_ptr被销毁，则该对象的生命期被延长至这个临时的shared_ptr同样被销毁

## 31. 调试程序的方法

- IDE设置断点进行调试
- Linux中没有IDE，可以打印log
- 打印中间结果
- 生成core文件

## 32. 遇到coredump要怎么调试

- 打开生成core文件的开关`ulimit -c unlimited`
- 输入`gdb core文件名 core`
- 输入`where`命令，可以找到错误的根源

## 33. 内存检查工具

- valgrind
- mtrace
- dmalloc
- memwatch
- mpatrol
- dbgmem
- Electric Fence

## 34. 成员初始化列表

成员初始化列表用来完成类中成员函数的初始化操作，初始化的顺序和在类中声明的顺序有关。

- 对于内置类型而言，在构造函数中使用初始化列表和在构造函数体中进行赋值，性能没什么差别
- 但是对于自定义类型而言，使用初始化列表可以使变量在初始化的时候直接调用拷贝构造函数即可；如果是在函数体中进行赋值，会先调用默认的构造函数创建该对象，然后调用赋值构造函数进行赋值。

## 35. lambda表达式

- lambda表达式 就是一个函数（匿名函数），也就是一个没有函数名的函数。为什么不需要函数名呢，因为我们直接（一次性的）用它，嵌入式用它，不需要其他地方调用它。
- lambda表达式也叫闭包。闭就是封闭的意思（封闭就是其他地方都不调用它），包就是函数。
- lambda表达式 其实就是一个函数对象，他内部创建了一个重载()操作符的类。
- lambda 表达式的简单语法如下：[capture] (parameters) -> return value { body },只有 [capture] 捕获列表和 { body } 函数体是必选的，其他可选。

```C++
int main()
{
	[] {}();//三部分，[] : 代表lambda表达式的开始;{} : 代表函数体，函数体里面什么都没有;() : 代表函数调用.
}

```

**捕捉变量**

变量捕获才是成就lambda卓越的秘方。

- [] 不捕获任何变量,这种情况下lambda表达式内部不能访问外部的变量。
- [&] 以引用方式捕获所有变量
- [=] 用值的方式捕获所有变量（可能被编译器优化为const &)
- [=, &foo] 以引用捕获变量foo, 但其余变量都靠值捕获
- [&, foo] 以值捕获foo, 但其余变量都靠引用捕获
- [bar] 以值方式捕获bar; 不捕获其它变量
- [this] 捕获所在类的this指针 （Qt中使用很多，如此lambda可以通过this访问界面控件的数据）

## 36. C++四种强制转换

- **static_cast：**用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型
  1.用于基本数据类型的转换
  2.用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用dynamic_cast进行下行转换。
  3.可以将空指针转化成目标类型的空指针
  4.可以将任何类型的表达式转化成void类型
- **const_cast：**强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）

- **reinterpret_cast：**改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型
- **dynamic_cast：**
  1.其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查
  2.只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回NULL；不能用于基本数据类型的转换
  3.在向上进行转换时，即子类的指针转换成父类的指针和static_cast效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）

## 37. 函数指针和指针函数

- 函数指针（指向函数的指针）：本质上是一个指针，只不过这个指针指向了一个函数，保存的是这个函数的地址（函数名）。int (*p)(int, int)//表示所指向的函数返回值是int型，参数是两个int型
- 指针函数（函数的返回值是指针）：本质上是一个函数，只不过返回值是指针类型。int* fun(int x, int y){}//这个fun函数的返回值是指针类型

## 38. auto和decltype的区别

auto和decltype都用于类型推导

- 语法格式不同：auto var = value; decltype(表达式) var2 [= value];
  auto根据=右面的初始值value推导出变量var的类型；
  decltype根据后面括号中的表达式推导出变量的类型，和=右面的value没有关系；
- auto要求变量必须初始化，即定义变量的时候必须赋值；
  decltype将变量的类型和初始值分开

## 39. 哪些运算符不能重载

C++中绝大部分运算符都能重载。
不能重载的运算符（只有5个）：

- . 成员访问运算符 ，保证访问成员的功能不能被改变
- .* 成员指针访问运算符，保证访问成员的功能不能被改变
- :: 域运算符，运算对象是类型而不是变量
- sizeof 长度运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征
- ?: 条件运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征

## 40. 运算符重载函数声明为一般函数还是友元函数，以及运算符重载的一些注意事项

- 运算符重载可以重载为类的成员函数，也可以是类的友元函数。
- 一般情况下，单目运算符重载为类的成员函数，双目运算符重载为类的友元函数

注意事项：

- 有五种不能重载的运算符："." , ".*", "::", "sizeof", "?:"
- 重载的运算符必须限制在可重载的运算符之中，不能创造新的运算符
- 遵循函数重载的原则，但是不能有默认的参数
- 重在后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构，不能改变内部对象的含义
- 自定义类型的运算符一般都先重载后使用，但是"="和“&”可以不用重载

